"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _umi() {
  const data = require("umi");

  _umi = function _umi() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _blockSdk() {
  const data = require("@umijs/block-sdk");

  _blockSdk = function _blockSdk() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const winPath = _umi().utils.winPath,
      createDebug = _umi().utils.createDebug;

const debug = createDebug('umi:umiui:UmiUI:block:tasks');

const generatorFunc = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (ctx, args) {
    const logger = ctx.logger,
          api = ctx.api;
    const dryRun = args.dryRun,
          isPage = args.page,
          js = args.js,
          _args$execution = args.execution,
          execution = _args$execution === void 0 ? 'shell' : _args$execution,
          uni18n = args.uni18n;
    logger.appendLog();
    logger.appendLog('📦  Start generate files');
    const BlockGenerator = (0, _blockSdk().getBlockGenerator)(ctx.api);
    const _ctx$stages$blockCtx = ctx.stages.blockCtx,
          pkg = _ctx$stages$blockCtx.pkg,
          sourcePath = _ctx$stages$blockCtx.sourcePath,
          filePath = _ctx$stages$blockCtx.filePath,
          routePath = _ctx$stages$blockCtx.routePath,
          templateTmpDirPath = _ctx$stages$blockCtx.templateTmpDirPath;
    let isPageBlock = pkg.blockConfig && pkg.blockConfig.specVersion === '0.1';

    if (isPage !== undefined) {
      // when user use `umi block add --page`
      isPageBlock = isPage;
    }

    debug(`isPageBlock: ${isPageBlock}`);
    const latestPkgPath = winPath((0, _path().join)(__dirname, '../../../../../package.json'));
    const generator = new BlockGenerator({
      name: args._ ? args._.slice(2) : [],
      args: {
        sourcePath,
        path: filePath,
        routePath,
        blockType: args.blockType,
        blockName: args.name || (0, _blockSdk().getNameFromPkg)(pkg),
        isPageBlock,
        dryRun,
        execution,
        env: {
          cwd: api.cwd
        },
        resolved: latestPkgPath
      }
    });

    try {
      yield generator.run();
    } catch (e) {
      logger.appendLog(`Faild generate files: ${e.message}\n`);
      throw new Error(e);
    } // write dependencies


    if (pkg.blockConfig && pkg.blockConfig.dependencies) {
      const subBlocks = pkg.blockConfig.dependencies;

      try {
        yield Promise.all(subBlocks.map(block => {
          const subBlockPath = (0, _path().join)(templateTmpDirPath, block);
          debug(`subBlockPath: ${subBlockPath}`);
          return new BlockGenerator({
            name: args._ ? args._.slice(2) : [],
            args: {
              sourcePath: subBlockPath,
              path: isPageBlock ? generator.path : (0, _path().join)(generator.path, generator.blockFolderName),
              blockName: (0, _blockSdk().getNameFromPkg)( // eslint-disable-next-line
              require((0, _path().join)(subBlockPath, 'package.json'))),
              isPageBlock: false,
              dryRun,
              env: {
                cwd: api.cwd
              },
              routes: api.userConfig.routes,
              resolved: latestPkgPath
            }
          }).run();
        }));
      } catch (e) {
        logger.appendLog(`Faild generate files: ${e.message}\n`);
        throw new Error(e);
      }
    }

    debug('Success generate files');
    logger.appendLog('🎉  Success generate files\n'); // 调用 sylvanas 转化 ts

    if (js) {
      // 区块需要拼接一下 blockName
      const relayPath = generator.isPageBlock ? generator.blockFolderPath : `${generator.blockFolderPath}/${generator.blockName}`;
      logger.appendLog('🎭  Start TypeScript to JavaScript');

      require('@umijs/block-sdk/lib/tsTojs').default(relayPath);

      logger.appendLog('🎉  Success TypeScript to JavaScript\n');
    }

    if (uni18n) {
      logger.appendLog('🌏  Start remove i18n code');

      require('@umijs/block-sdk/lib/remove-locale').default(generator.blockFolderPath, uni18n);

      logger.appendLog('🎉  Success remove i18n code\n');
    }

    ctx.stages.generator = generator;
    debug('run_generator finish');
  });

  return function generatorFunc(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var _default = generatorFunc;
exports.default = _default;